<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Tarea corta 3 con D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-fetch.v1.min.js"></script>
</head>
<body>
    <h1>Visualización del mapa de Estados Unidos</h1>

    <!-- SVG para visualizar datos  estados USA-->
    <svg id="bnaDemo" width="1400" height="1000" style="border: 1px solid black;"></svg>

    <script>
        const csvFilePath = "./states_name.csv"; // Ruta al archivo CSV
        const bnaFilePath = "./states_usa.bna"; // Ruta al archivo BNA
    
        // Cargar datos del CSV y BNA usando Promise.all
        Promise.all([d3.csv(csvFilePath), d3.text(bnaFilePath)])
            .then(([csvData, bnaData]) => {
                // Convertir campos numéricos en CSV
                csvData.forEach(d => {
                    d.id = parseInt(d.id, 10); // Convertir ID a número entero
                });
                csvData.forEach(d => {
                    d.id = d.ID; // Cambia el nombre del campo para que coincida con 'datosBNA'
                });
                // Unir datos por ID
                const bnaSegments = parseBna(bnaData); // Procesar el archivo BNA
                const combinedData = joinById(bnaSegments, csvData); // Unir por ID

                // Crear SVG para dibujar
                const svg = d3.select("#bnaDemo")
                    .attr("width", 1400)
                    .attr("height", 1000);
                // Dibujar caminos en el SVG
                drawPaths(svg, combinedData);
            })
            .catch(error => {
                console.error("Error al cargar los datos:", error);
            });
    
        // Función para extraer segmentos del archivo BNA
        function parseBna(data) {
            const lines = data.split("\n");
            const segments = [];
            let currentSegment = null;
    
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.length === 0) {
                    return; // Ignorar líneas vacías
                }
    
                const parts = trimmedLine.split(",");
                if (parts.length === 3) {
                    if (currentSegment) {
                        segments.push(currentSegment); // Guardar el segmento anterior
                    }
    
                    currentSegment = {
                        id: parts[0], // ID del segmento
                        sequence: parseInt(parts[1], 10), // Secuencia
                        unknownValue: parseInt(parts[2], 10),
                        coordinates: [],
                    };
                } else if (parts.length === 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y) && currentSegment) {
                        currentSegment.coordinates.push({ x, y });
                    }
                }
            });
    
            if (currentSegment) {
                segments.push(currentSegment); // Guardar el último segmento
            }
    
            return segments; // Devuelve todos los segmentos
        }
    
        // Función para unir datos por ID
        function joinById(datosBNA, datosCSV) {
            //Hace un inner join por id entre los datos para graficar los estados y sus respectivos nombres
            const map = {};
            datosBNA.forEach(d => {
                map[d.id] = { ...d };
            });
            datosCSV.forEach(d => {
                if (map[d.id]) {
                    map[d.id] = { ...map[d.id], ...d };
                }
            });
            return Object.values(map); // Devuelve array del inner join
        }
        function getRandomColor(indice) {
            const colors = [
                "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4",
                "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff",
                "#9a6324", "#fffac8", "#800000", "#aaffc3", "#808000", "#ffd8b1",
                "#87CEEB", "#808080", "#ffffff", "#FFFF00", "#1f77b4", "#ff7f0e",
                "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f",
                "#bcbd22", "#17becf", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94",
                "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5", "#aec7e8", "#ffbb78",
                "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7",
                "#dbdb8d", "#9edae5"
            ];

            
            return colors[indice]; // Retornar color aleatorio
        }
        // Función para dibujar caminos con escalas
        function drawPaths(svg, segments) {
            var indice=0
            const xScale = d3.scaleLinear()
                .domain([-125, -65])
                .range([0, 1400]); // Ancho del SVG

            const yScale = d3.scaleLinear()
                .domain([25, 50])
                .range([1000, 0]); // Alto del SVG

            // Crear un grupo para el comportamiento de zoom
            const zoomGroup = svg.append("g"); // Contenedor para el contenido

            // Configurar el comportamiento de zoom
            const zoom = d3.zoom()
                .scaleExtent([0.5, 10]) // Limitar el nivel de zoom (mínimo y máximo)
                .on("zoom", (event) => {
                    // Aplicar la transformación del zoom al grupo
                    zoomGroup.attr("transform", event.transform);
                });

            // Aplicar el comportamiento de zoom al SVG
            svg.call(zoom);

            segments.forEach(segment => {
                const path = d3.path(); // Crear objeto path
                const scaledCoords = segment.coordinates.map(coord => ({
                    x: xScale(coord.x),
                    y: yScale(coord.y),
                }));

                if (scaledCoords.length > 0) {
                    path.moveTo(scaledCoords[0].x, scaledCoords[0].y);
                    scaledCoords.forEach((coord, index) => {
                        if (index > 0) {
                            path.lineTo(coord.x, coord.y);
                        }
                    });

                    // Dibujar el camino dentro del grupo de zoom
                    zoomGroup.append("path")
                        .attr("d", path.toString())
                        .attr("stroke", "green")
                        .attr("fill", getRandomColor(indice));

                    // Calcular el centro del camino para colocar el texto
                    const centerX = scaledCoords.reduce((sum, coord) => sum + coord.x, 0) / scaledCoords.length;
                    const centerY = scaledCoords.reduce((sum, coord) => sum + coord.y, 0) / scaledCoords.length;

                    // Añadir texto para mostrar el nombre del segmento
                    zoomGroup.append("text")
                        .attr("x", centerX) // Posición horizontal
                        .attr("y", centerY) // Posición vertical
                        .attr("text-anchor", "middle") // Centrar el texto
                        .attr("font-size", "11px") // Tamaño de la fuente
                        .text(segment.CODE); // Mostrar el nombre del segmento
                    indice++;
                }
            });
        }   
    </script>



    <!-- SVG para visualizar datos distritos de CR-->
    <svg id="treeMap" width="1800" height="1800" >
        <text x="200" y="20" text-anchor="middle" font-size="24" font-family="Arial" fill="black">
            Gráfico TreeMap distritos CR
        </text>
    </svg>
    <svg id="radiaLayout" width="1000" height="1000" >
        <text x="200" y="20" text-anchor="middle" font-size="24" font-family="Arial" fill="black">
            Gráfico Radial distritos CR
        </text>
    </svg>
    <svg id="partitionLayout" width=750 height=750 transform="rotate(-90), translate(20,0)"></svg>
    <script>
    // Define la función para visualizar datos en el SVG
    function drawText(selector, data) {
        const svg = d3.select(selector);
        // Elimina cualquier texto existente
        svg.selectAll("text").remove();
        
        // Agrega texto para cada elemento del JSON
        svg.selectAll("text")
          .data(data) // Vincula los datos al SVG
          .enter() // Crea nuevos elementos de texto
          .append("text")
          .attr("x", 10) // Posición horizontal
          .attr("y", (d, i) => (i + 1) * 20) // Posición vertical (20px entre líneas)
          .text(d => d.ID + ": " + d.POBL_2000); // Muestra id y valor
    }
    function createHierarchy(data) {
        return {
            name: "root", // Nodo raíz
            children: data.map(d => ({
                name: d.ID, // Nodo principal basado en el ID
                children: [ // Campos relacionados como hijos
                    { name: "COD_POSTAL", value: d.COD_POSTAL },
                    { name: "AREA_KM2", value: d.AREA_KM2 },
                    { name: "POBL_2022", value: d.POBL_2022 },
                    { name: "POBL_2011", value: d.POBL_2011 },
                    { name: "POBL_2000", value: d.POBL_2000 }
                ]
            }))
        };
    }
    function drawTreeMap(selector, data) {
        const svg = d3.select(selector); // Seleccionar el SVG
        svg.selectAll("g").remove(); // Eliminar grupos anteriores para limpiar el área

        // Crear la jerarquía
        const root = d3.hierarchy(data) // Convertir el objeto jerárquico en una jerarquía
            .sum(d => d.value || 0); // Usar 'value' como valor para el Treemap

        const treemap = d3.treemap()
            .size([1800, 1800]) // Tamaño del Treemap
            .paddingOuter(10); // Espaciado exterior

        treemap(root); // Aplicar el Treemap a la jerarquía

        const group = svg.append("g"); // Grupo para el contenido del Treemap

        // Dibujar los nodos del Treemap
        group.selectAll("rect")
            .data(root.leaves()) // Obtener las hojas del Treemap
            .enter()
            .append("rect")
            .attr("x", d => d.x0) // Posición horizontal
            .attr("y", d => d.y0) // Posición vertical
            .attr("width", d => d.x1 - d.x0) // Ancho del nodo
            .attr("height", d => d.y1 - d.y0) // Altura del nodo
            .attr("fill", "lightsteelblue"); // Color de fondo

        // Añadir texto para cada nodo
        //group.selectAll("text")
        //    .data(root.leaves()) // Obtener las hojas del Treemap
        //    .enter()
        //    .append("text")
        //    .attr("x", d => (d.x0 + d.x1) / 2) // Centrar horizontalmente
        //    .attr("y", d => (d.y0 + d.y1) / 2) // Centrar verticalmente
        //    .attr("text-anchor", "middle") // Centrar el texto
        //    .text(d => `${d.data.name}: ${d.data.value}`); // Mostrar el nombre y el valor
    }
    function drawRadiaLayout(selector, data) {
        const svg = d3.select(selector)
        .attr("width", 1500) // SVG más grande para mayor espacio
        .attr("height", 1500); // SVG más grande para mayor espacio

        const radius = 700; // Radio extendido para mayor separación entre nodos

        const group = svg.append("g")
            .attr("transform", `translate(${radius}, ${radius})`); // Centrar el grupo

        const root = d3.hierarchy(data); // Construir la jerarquía
        const cluster = d3.cluster() // Crear el layout radial
            .size([360, radius]); // Configurar el tamaño del layout radial para cubrir 360 grados

        cluster(root); // Aplicar el layout radial

        // Dibujar las conexiones entre nodos con líneas curvas para mayor claridad
        const linkGroup = group.append("g")
            .classed("links", true);

        linkGroup.selectAll("path")
            .data(root.links()) // Obtener todas las conexiones
            .enter()
            .append("path")
            .classed("link", true)
            .attr("d", d3.linkRadial() // Usar linkRadial para líneas curvas
                .angle(d => (d.x * Math.PI) / 180) // Convertir grados a radianes
                .radius(d => d.y)) // Radio del enlace
            .attr("stroke", "gray")
            .attr("stroke-width", 1) // Grosor reducido para claridad
            .attr("fill", "none"); // Sin relleno

        // Dibujar los nodos con menor tamaño para evitar superposición
        const nodeGroup = group.append("g")
            .classed("nodes", true);

        nodeGroup.selectAll("circle")
            .data(root.descendants()) // Obtener todos los nodos
            .enter()
            .append("circle")
            .classed("node", true)
            .attr("r", 3) // Radio del círculo reducido
            .attr("cx", d => Math.cos((d.x - 90) * (Math.PI / 180)) * d.y) // Coordenada radial x
            .attr("cy", d => Math.sin((d.x - 90) * (Math.PI / 180)) * d.y) // Coordenada radial y
            .attr("fill", "lightblue")
            .attr("stroke", "darkgray")
            .attr("stroke-width", 0.5); // Grosor reducido para nodos
    }


    function drawPartitionLayaout(selector, data){
        var root = d3.hierarchy(data)
            .count();
        console.log("Hierarchical data:", root.descendants().map(d => d.data));
        // Crear particionamiento
        var partition = d3.partition()
            .size([2200, 2200]) // Asegúrate de que el tamaño es suficiente
            .padding(15); // Usa padding para separar nodos
        
        partition(root); // Aplicar el layout

        // Seleccionar el SVG o el contenedor
        const svg = d3.select(selector);

        // Dibujar los nodos (rectángulos)
        svg.selectAll('rect.node')
            .data(root.descendants()) // Obtener todos los descendientes
            .enter()
            .append('rect')
            .classed('node', true)
            .attr('x', d => d.x0) // Posición horizontal
            .attr('y', d => d.y0) // Posición vertical
            .attr('width', d => d.x1 - d.x0) // Ancho del rectángulo
            .attr('height', d => d.y1 - d.y0) // Altura del rectángulo
            .attr('fill', "lightblue") // Color de relleno
            .attr('stroke', "darkgray"); // Color del borde
        }
    function drawCirclePacking(){
        const svg = d3.select(selector);
        svg.selectAll("text").remove();
    }
    function drawSunBurst(){
        const svg = d3.select(selector);
        svg.selectAll("text").remove();
    }

    // Carga el archivo JSON y muestra datos en el SVG
    d3.csv("./distritos_cr.json") 
      .then(function(data) {
        data.forEach(d => {
            // Convertir campos numéricos a tipos adecuados
            d.AREA_KM2 = parseFloat(d.AREA_KM2); // Convertir a número
            d.POBL_2000 = parseInt(d.POBL_2022, 10); // Convertir a número entero
            d.POBL_2011 = parseInt(d.POBL_2022, 10);
            d.POBL_2022 = parseInt(d.POBL_2022, 10);
        });
        const hierarchy = createHierarchy(data);
        

        drawTreeMap("#treeMap", hierarchy); // Muestra datos en el SVG
        drawRadiaLayout("#radiaLayout", hierarchy);
        drawPartitionLayaout("#partitionLayout", hierarchy);
      })
      .catch(function(error) {
        console.error("Error al cargar el JSON:", error); // Captura errores al cargar JSON
      });
    </script>
</body>
</html>